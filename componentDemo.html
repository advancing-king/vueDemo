<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<script src="js/vue.js"></script>
<body>
<div id="example">
    <p>自定义元素</p>
    <my-component></my-component>
</div>

<div id="example-2">
    <simple-counter></simple-counter>
    <simple-counter></simple-counter>
    <simple-counter></simple-counter>
</div>

<div id="example-3">
    <simple-counter2></simple-counter2>
    <simple-counter2></simple-counter2>
    <simple-counter2></simple-counter2>
</div>

<div id="example-4">
    <p>使用props显示声明</p>
    <child message="hello!"></child>
</div>

</body>

<script type="text/javascript">

    /**
     * 组件实例的作用域是孤立的。
     * 这意味着不能(也不应该)在子组件的模板内直接引用父组件的数据。
     * 要让子组件使用父组件的数据，我们需要通过子组件的props选项。
     * 子组件要显式地用 props 选项声明它期待获得的数据：
     */
    Vue.component('child', {
        // 声明 props
        props: ['message'],
        // 就像 data 一样，prop 可以用在模板内
        // 同样也可以在 vm 实例中像 “this.message” 这样使用
        template: '<span>{{ message }}</span>'
    })

    new Vue({
        el:"#example-4"
    })

    Vue.component('simple-counter2', {
        template: '<button v-on:click="counter += 1">{{ counter }}</button>',
        // 技术上 data 的确是一个函数了，因此 Vue 不会警告，
        // 但是我们返回给每个组件的实例的却引用了同一个data对象
        data: function () {
            return {counter:0}
        }
    })
    new Vue({
        el: '#example-3'
    })
    var data = { counter: 0 }
    Vue.component('simple-counter', {
        template: '<button v-on:click="counter += 1">{{ counter }}</button>',
        // 技术上 data 的确是一个函数了，因此 Vue 不会警告，
        // 但是我们返回给每个组件的实例的却引用了同一个data对象
        data: function () {
            return data
        }
    })
    new Vue({
        el: '#example-2'
    })
    Vue.component('my-component',{
        template: '<div>A custom component!</div>'
    })
    var example = new Vue({
        el:"#example"

    })
</script>
</html>